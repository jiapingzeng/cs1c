package subsetsum;

import cs1c.SongEntry;

import java.util.ArrayList;
import java.util.TreeMap;

/**
 * Solves Subset Sum problem for ShoppingBag and FoothillTunesStore
 *
 * @author Jiaping Zeng
 */

public class SubsetSum {

    /**
     * Finds subset with sum equal to or closest to target
     * @param list list of items to select from
     * @param target target sum
     * @return subset found
     */
    public static ArrayList<Double> findSubset(ArrayList<Double> list, double target) {
        if (target >= getSum(list)) {
            // have enough budget to buy everything
            return list;
        } else if (list.isEmpty()) {
            // shopping list is empty
            System.out.println("Received list is empty. Please try adding more items to the list.");
            return null;
        } else if (target <= getSmallest(list)) {
            // budget is smaller than cheapest item
            System.out.println("Not enough budget to buy anything. Please try increasing your budget.");
            return null;
        } else {
            ArrayList<ArrayList<Double>> sets = new ArrayList<>();
            // initialize sets variable with an empty set
            sets.add(new ArrayList<>());
            for (double item : list) {
                ArrayList<ArrayList<Double>> newSets = new ArrayList<>();
                for (ArrayList<Double> set : sets) {
                    double newSum = getSum(set) + item;
                    if (newSum == target) {
                        // found solution that matches budget exactly
                        set.add(item);
                        return set;
                    } else if (newSum < target) {
                        // still below budget, add as new set
                        ArrayList<Double> newSet = new ArrayList<>(set);
                        newSet.add(item);
                        newSets.add(newSet);
                    }
                }
                sets.addAll(newSets);
            }
            return getLargestSet(sets);
        }
    }

    /**
     * Finds playlist with total duration equal to or closest to target duration
     * @param list list of songs to select from
     * @param duration target duration (in minutes)
     * @return playlist found
     */
    public static ArrayList<SongEntry> findSubsetOfSongs(ArrayList<SongEntry> list, double duration) {
        int target = (int)(duration * 60); // convert from minutes to seconds
        int totalDuration = getTotalDurationInSeconds(list);
        System.out.println("Received list of songs with total duration " + totalDuration + " seconds");
        System.out.println("Generating playlist with total duration of " + target + " seconds");
        if (list.isEmpty() || target <= 0) {
            System.out.println("Unable to find playlist");
            return new ArrayList<>();
        }
        if (target > totalDuration) {
            System.out.println("Target duration is greater than length of all songs combined");
            return list;
        }
        TreeMap<Integer, SongEntry> map = new TreeMap<>();
        map.put(0, null);
        for (SongEntry song : list) {
            TreeMap<Integer, SongEntry> newItems = new TreeMap<>(); // items to be added after loop
            for (int key : map.keySet()) {
                int newDuration = key + song.getDuration();
                if (newDuration == target) {
                    // solution found, return
                    map.put(newDuration, song);
                    ArrayList<SongEntry> solution = getSolution(map, target);
                    System.out.println("Found playlist with duration " + getTotalDurationInSeconds(solution) + " seconds");
                    return solution;
                } else if (newDuration < target) {
                    if (!map.containsKey(newDuration)) {
                        // avoid overwriting solved entries
                        newItems.put(newDuration, song);
                    }
                } else {
                    // since TreeMap is sorted, newDuration > target means that newDuration is already over target duration
                    // and subsets after this will also be over target duration, no need to continue
                    break;
                }
            }
            map.putAll(newItems);
        }
        ArrayList<SongEntry> solution = getSolution(map, target);
        System.out.println("Found playlist with duration " + getTotalDurationInSeconds(solution) + " seconds");
        return solution;
    }

    /**
     * Gets solution in map
     * @param map map generated by findSubsetOfSongs
     * @param key key to retrieve from, also total duration of solution
     * @return list of songs that add up to key
     */
    private static ArrayList<SongEntry> getSolution(TreeMap<Integer, SongEntry> map, int key) {
        ArrayList<SongEntry> solution = new ArrayList<>();
        SongEntry item;
        if (map.containsKey(key)) {
            item = map.get(key);
        } else {
            // no exact solution found, return largest instead
            return getSolution(map, map.lastKey());
        }
        solution.add(item);
        if (key > item.getDuration()) {
            // if song duration is greater than key (which is total duration of subset), then
            // there are more songs in the subset, retrieve the other songs recursively
            solution.addAll(getSolution(map, key - item.getDuration()));
        }
        return solution;
    }

    //-----------HELPER METHODS--------------

    /**
     * Returns the cheapest item in the list
     * @param list shopping list
     * @return cheapest item on the list
     */
    private static double getSmallest(ArrayList<Double> list) {
        double smallest = list.get(0);
        for (double item : list) {
            if (item < smallest) {
                smallest = item;
            }
        }
        return smallest;
    }

    /**
     * Returns the sum of everything on the list
     * @param list shopping list
     * @return sum of everything on the list
     */
    private static double getSum(ArrayList<Double> list) {
        double sum = 0.0;
        for (double item : list) sum += item;
        return sum;
    }

    /**
     * Finds and returns the subset with the largest sum
     * @param sets sets to read from
     * @return largest set found
     */
    private static ArrayList<Double> getLargestSet(ArrayList<ArrayList<Double>> sets) {
        if (sets.isEmpty()) {
            // input is empty
            return null;
        }
        double largestSum = 0.0;
        ArrayList<Double> largestSet = new ArrayList<>();
        for (ArrayList<Double> set : sets) {
            double sum = getSum(set);
            if (sum > largestSum) {
                largestSum = sum;
                largestSet = set;
            }
        }
        return largestSet;
    }

    /**
     * Finds total duration of list of songs
     * @param songs list of songs
     * @return total duration (in seconds)
     */
    private static int getTotalDurationInSeconds(ArrayList<SongEntry> songs) {
        int duration = 0;
        for (SongEntry song : songs) duration += song.getDuration();
        return duration;
    }
}
